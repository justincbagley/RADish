#!/bin/sh

##########################################################################################
#                           minor012-bayenv2 v0.1.0, May 2018                            #
#  SCRIPT FOR CONVERTING MINOR-ALLELE-CODED 012 GENOTYPE MATRIX INTO 'SNPSFILE' INPUT    #
#  FILE OF ALLELE COUNTS OF *POLYMORPHIC LOCI ONLY* FOR BAYENV2                          #
#  Copyright ©2018 Justinc C. Bagley. For further information, see README and license    #
#  available in the RADish repository (https://github.com/justincbagley/RADish/). This   #
#  script was last updated May 22, 2018. For questions, please email jcbagley@vcu.edu.   #
##########################################################################################

############ SCRIPT OPTIONS
## OPTION DEFAULTS ##
MY_INPUT_012_FILE=NULL
MY_POP_FILE=pop.txt
MY_NUM_SNPS=1000

############ CREATE USAGE & HELP TEXTS
## Justin's Usage note: 
# cd /gpfs_fs/home/eckertlab/Mitra/chapter2/dDocent3489_SNPs_JCB/Periphery/104pops_run3_full_2/
# ./minor012-bayenv2 -i minor_012_104pops_2.txt -p ./104pops.txt -n 72889

## Usage text for users:
Usage="Usage: $(basename "$0") [Help: -h help] [Options: -i p n] workingDir 
 ## Help:
  -h   help text (also: -help)

 ## Options:
  -i   inputFile (def: NULL) name of minor-allele-coded 012 file
  -p   popFile (def: pop.txt) population file for counting alleles by population
  -n   numSNPs (def: 1000) total number of SNPs in data matrix

 OVERVIEW
 THIS SCRIPT converts a SNP genotype file in '012' format into the 'SNPSFILE' input file 
 format for Bayenv2 (Günther and Coop 2013). The '012' file must be a matrix containing  
 the genotypes of each individual on a separate line, for each SNP (columns), while 
 coding the genotypes as counts of the minor allele, and not the major allele (as is 
 more commonly done). Three inputs are required, including 1) the minor-allele-coded 012 
 file, 2) a population file containing the name of each population, and 3) the total number 
 of SNPs in the dataset. 
	In GBS and RADseq workflows, 012 files are typically generated by converting from VCF 
 format to 012 format using recode commands available in vcftools. However, when preparing 
 the 012 file for the present script using vcftools, users will need to use the '--non-ref-ac' 
 flag etc. to ensure correct coding; simply using the '--012' flag in vcftools will result 
 in an inappropriate input file with counts of the reference/major allele, and will yield 
 incorrect results. In addition to these requirements, the start (1st column) of each line
 in the 012 file must contain the name of the sample/individual for which the SNP data are 
 provided on the rest of the corresponding line. Thus, if L is the total number of SNP loci, 
 then the 012 file will contain L+1 columns. Another important requirement of the 012 file 
 is that each sample/individual name must contain the name of the population from which the
 individual was sampled, which must match the population name in the population file.
	The population file is related to the 012 input file and lists the name of each population
 from which individuals were sampled, given one per line.
	The default value for the total number of SNPs is '1000' and this is likely to be 
 incorrect for most users. Please set this value to the correct number of SNPs in your dataset.
 If this value undershoots the actual number of SNPs, then SNPs that are left out wil not
 be present in the resulting Bayenv2 input file.
	Population names must include *only* alphanumeric characters and underscores. Hyphen
 characters should not be included, or there could be issues. The bash shell is assumed, and
 dependencies include grep, AWK, and sed.

 CITATION
 Bagley, J.C. 2017. RADish v0.1.0. GitHub repository, Available at:  
	<http://github.com/justincbagley/RADish>.

 REFERENCES
 Günther T, Coop G (2013) Robust identification of local adaptation from allele frequencies. 
	Genetics, 195(1), 205-220.
"

## NEED TO FINISH VERBOSE HELP! (here)
## Usage="Usage: $(basename "$0") [Help: -h help H Help] [Options: -i p n] workingDir 
## "
## This will be accessed with:   -H   verbose help text (also: -Help)

if [[ "$1" == "-h" ]] || [[ "$1" == "-help" ]]; then
	echo "$Usage"
	exit
fi

## if [[ "$1" == "-H" ]] || [[ "$1" == "-Help" ]]; then
## 	echo "$verboseHelp"
## 	exit
## fi

############ PARSE THE OPTIONS
while getopts 'i:p:n:' opt ; do
  case $opt in

## script options:
    i) MY_INPUT_012_FILE=$OPTARG ;;
    p) MY_POP_FILE=$OPTARG ;;
    n) MY_NUM_SNPS=$OPTARG ;;

## Missing and illegal options:
    :) printf "Missing argument for -%s\n" "$OPTARG" >&2
       echo "$Usage" >&2
       exit 1 ;;
   \?) printf "Illegal option: -%s\n" "$OPTARG" >&2
       echo "$Usage" >&2
       exit 1 ;;
  esac
done

############ SKIP OVER THE PROCESSED OPTIONS
shift $((OPTIND-1)) 
# Check for mandatory positional parameters
if [ $# -lt 1 ]; then
echo "$Usage"
  exit 1
fi
USER_SPEC_PATH="$1"

echo "INFO      | $(date) |          Setting user-specified path to: "
echo "$USER_SPEC_PATH "	


echo "
##########################################################################################
#                           minor012-bayenv2 v0.1.0, May 2018                            #
##########################################################################################
"

######################################## START ###########################################
## SETUP
MY_PATH=`pwd -P`
calc () { 
	bc -l <<< "$@"  
}

## Make three subfolders used to organize output and data/count files:
mkdir outfiles pop_data pop_allele_counts

	############################### minor012-bayenv2Converter.sh ###############################
	
	minor012-bayenv2Converter () {
	
	while read popname; do 

		## SPLIT MINOR 012 FILE
		## Prep dir structure, split minor012 file into separate files by pop, count sample sizes
		## for each pop, and save pop names and sample sizes to summary txt files:
		echo ""
		echo "INFO      | $(date) |          ## ------------------ Current Population: $popname ------------------ ##"
		echo "$popname" >> ./popNamesOrderCheck.txt; 
		grep -h "$popname" "$MY_INPUT_012_FILE" | wc -l >> ./popSampleSizes.txt; 
		grep -h "$popname" "$MY_INPUT_012_FILE" > ./"$popname".txt;  

		## OUTPUT MINOR ALLELE AND MAJOR ALLELE COUNTS AS COLUMNS OF FINAL FILE, WITH 2 ROWS
		## PER SNP LOCUS (one w/minor allele count, one w/ major allele count)
		TOTAL_NUM_COLS="$(calc $MY_NUM_SNPS+1)"
		(
			for i in $(seq 2 $TOTAL_NUM_COLS); do 
	#
				MY_CURRENT_LOCUS="$(calc $i-1)"
				echo "INFO      | $(date) |          Counting alleles for Locus $MY_CURRENT_LOCUS ... "
				## CALCULATE MINOR ALLELE COUNTS FOR LOCUS i-1:
				## Idea from URL: http://www.liamdelahunty.com/tips/linux_ls_awk_totals.php and URL: https://stackoverflow.com/questions/20332038/using-a-user-set-variable-in-an-awk-command provided inspiration for -v flag usage.
				MY_MINOR_ALLELE_COUNT="$(cat ./$popname.txt | awk -v i="$i" '{ SUM += $i } END { print SUM }')";
				echo "$MY_MINOR_ALLELE_COUNT" >> ./"$popname"_counts.txt;
	#
				## CALCULATE MINOR ALLELE COUNTS FOR LOCUS i-1:
				MY_NONMISSING_IND_COUNTS="$(awk -v i="$i" '{print $i}' ./$popname.txt  | sort | uniq -c | grep -v 'NA' | sed s/[^\ +0-9\{1,2\}][NA0-9].*$//g | sed 's/^\ \{4,6\}//g' | sed 's/\ .*//g' | tr '\n' '+' | sed 's/+$//g' )"; 
				##echo "$MY_NONMISSING_IND_COUNTS";
				MY_NONMISSING_IND_TOTAL="$(calc $MY_NONMISSING_IND_COUNTS)"; 
				MY_NONMISSING_IND_TOTAL_X2="$(calc $MY_NONMISSING_IND_TOTAL*2)"; 
				MY_MAJOR_ALLELE_COUNT="$(calc $MY_NONMISSING_IND_TOTAL_X2-$MY_MINOR_ALLELE_COUNT)";
				echo "$MY_MAJOR_ALLELE_COUNT" >> ./"$popname"_counts.txt;
	#
			done
		)


		## Final file manipulations for the current pop/popfile:
		mv ./"$popname".txt ./pop_data/
	
		mv ./"$popname"_counts.txt ./pop_allele_counts/
	
		echo ./"$popname"_counts.txt >> ./popCountsOrderCheck.txt;



	done < "$MY_POP_FILE"



	## CLEANUP AND ORGANIZE FILES:
	## Save final pop names and sample sizes into final summary txt file:
		paste ./popNamesOrderCheck.txt ./popSampleSizes.txt > ./popOrderSampleSizes.txt

	## Organize files:
		mv ./popNamesOrderCheck.txt ./outfiles/
		mv ./popSampleSizes.txt ./outfiles/ 
		mv ./popCountsOrderCheck.txt ./outfiles/ 
		mv ./popOrderSampleSizes.txt ./outfiles/



	## PASTE COUNTS FILES TOGETHER TO MAKE FINAL BAYENV2 INPUT FILE:
	echo "INFO      | $(date) |          Creating final Bayenv2 input file from the full population allele counts... "
		cd ./pop_allele_counts/
		MY_COUNTFILES_LIST="$(ls ./*.txt | tr '\n' ' ')"
	
		for i in 1; do paste $(echo $MY_COUNTFILES_LIST) > bayenv2_input.txt; done
	
		mv ./bayenv2_input.txt ../outfiles/;
		## cp ./bayenv2_input.txt ../ ;		## Uncomment this line if needed...

}

minor012-bayenv2Converter



########  ***  NEW CODE FOR CHECKING & FIXING BAYENV2 INPUT FILE CREATED ABOVE  ***  #####

	###### MAKE/RUN R SCRIPT THAT VISUALLY COMPARES K MARGINAL LIKELIHOODS ACROSS K, ACROSS ASSEMBLIES.
	##--Before making the script, first set some environmental variables that FIX issues 
	##--with echoing shell text containing dollar signs to Rscript:
	MY_POINTS_VAR="$(echo "\$points")"			## Make points variable with '$points' text for Rscript...
	MY_RF_VAR="$(echo "\$RF")"					## Make variable with '$RF' text (RF distance column heading) for Rscript...

	############ MAKE R SCRIPT
	echo "
#!/usr/bin/env Rscript

############################### identifyZeroSumRows.R ###############################

############ I. SETUP
setwd('$MY_PATH')
##setwd('/Users/justinbagley/Documents/2\ -\ by\ Project/SWWP_Adapt/Periphery')

############ II. READ DATA AND DO PROCEDURE
bayenvIn <- read.table(file='bayenv2_input.txt', header=FALSE, sep='\t')
dim(bayenvIn)
## [1] 145778    104

bayenvIn_rowsums <- rowSums(bayenvIn)
bayenvIn_rowsums
#  [1]   50 1712  241 1547  255 1317  168  910    9 1709  360 1240    7 1733   19 1745   14 1708    3 1563   66 1084  103 1393
# [25]    1 1353   60 1544    2 1466    3 1795    2 1468   14 1250    6 1826   63 1087  561  727   15 1355   10 1742   50 1626
# [49]    2 1276   58 1772    7 1663  233 1185  393 1199    5 1105   13 1279    8 1682   32 1768  116 1020    4 1544   10 1050
# [73]    2 1596   15 1273   37 1365   16 1110    8 1182   11 1051   38 1632  241  939  430  842   19 1273   12 1412    8 1646
# [97]   47 1701   17 1067
# [ reached getOption("max.print") -- omitted 145678 entries ]
 
bayenvIn_no0 = bayenvIn[ rowSums(bayenvIn)!=0, ]		## Idea from URL: http://r.789695.n4.nabble.com/How-to-delete-rows-from-dataframe-that-sum-to-zero-td4589289.html
dim(bayenvIn)
## [1] 145778    104
dim(bayenvIn_no0)
## [1] 145734    104
num_problem_SNPs <- c(dim(bayenvIn) - dim(bayenvIn_no0))
num_problem_SNPs
## [1] 44  0
num_problem_SNPs[1]		## This is what you need to allocate space in loop below.
## [1] 44

## IDENTIFY ZERO SUM ROWS 
results <- matrix(NA, nrow=num_problem_SNPs[1], ncol=1)
count=1
for(i in 1:nrow(bayenvIn)){
	if (rowSums(bayenvIn[i,]) == '0') {
		  results[count, ] <- rownames(bayenvIn[i,])
	count=count+1
	}
}
write.table(results, file="zeroSumRows.txt", row.names=FALSE, col.names=FALSE, quote=FALSE)

######################################### END ############################################
" > identifyZeroSumRows.r


#echo "INFO      | $(date) | RUN THE R SCRIPT! (WHICH ALSO SAVES RESULTS TO FILE). "
	R CMD BATCH ./identifyZeroSumRows.R





	################################### removeFixedSNPs.sh ####################################

	####### SETUP:
	calc () { 
		bc -l <<< "$@" 
	}

	removeFixedSNPs () {

	####### CHECK MACHINE TYPE:
	##--This idea and code came from the following URL (Lines 87-95 code is reused here): 
	##--https://stackoverflow.com/questions/3466166/how-to-check-if-running-in-cygwin-mac-or-linux 
	unameOut="$(uname -s)"
	case "$unameOut" in
	    Linux*)     machine=Linux;;
	    Darwin*)    machine=Mac;;
	    CYGWIN*)    machine=Cygwin;;
	    MINGW*)     machine=MinGw;;
	    *)          machine="UNKNOWN:$unameOut"
	esac
	echo "INFO      | $(date) | System: $machine"



	if [[ "$machine" = "Mac" ]]; then

	####### CASE 1: LOCAL MAC MACHINE 

	####### RUN LOCALLY:
	(
		echo "INFO      | $(date) | Removing problem SNP #1... "
		line="$(head -n1 ./zeroSumRows.txt)"
	#
			if [[ $((line % 2)) -eq 0 ]]; then
				##echo "$var is even"; 
				MY_LINE_MINUS_ONE="$(calc $line-1)";
				sed -i '' ''"$MY_LINE_MINUS_ONE"','"$line"'d' ./bayenv2_input.txt;
			else 
				##echo "$var is odd"; 
				MY_LINE_PLUS_ONE="$(calc $line+1)";
				sed -i '' ''"$line"','"$MY_LINE_PLUS_ONE"'d' ./bayenv2_input.txt; 
			fi
	#
	)

	sed -i '' '1d' ./zeroSumRows.txt

	(
		count=1
		while read line; do
	#
			MY_DIFF="$(calc $count*2)"
			MY_NEW_LINE="$(calc $line-$MY_DIFF)"
			if [[ $((line % 2)) -eq 0 ]]; then
				##echo "$var is even"; 
				MY_NEW_LINE_MINUS_ONE="$(calc $MY_NEW_LINE-1)";
				sed -i '' ''"$MY_NEW_LINE_MINUS_ONE"','"$MY_NEW_LINE"'d' ./bayenv2_input.txt;
			else 
				##echo "$var is odd"; 
				MY_NEW_LINE_PLUS_ONE="$(calc $MY_NEW_LINE+1)";
				sed -i '' ''"$MY_NEW_LINE"','"$MY_NEW_LINE_PLUS_ONE"'d' ./bayenv2_input.txt; 
			fi
	#
		MY_COUNT_PLUS_ONE="$(calc $count+1)"
		echo "INFO      | $(date) | $((count++))+1 = Removing problem SNP #$MY_COUNT_PLUS_ONE... "
		done < ./zeroSumRows.txt
	
	)
	
	fi




	if [[ "$machine" = "Linux" ]]; then

	####### CASE 2: LINUX AND/OR LINUX-BASED SUPERCOMPUTER ENVIRONMENT 

	####### RUN ON LINUX AND/OR LINUX-BASED SUPERCOMPUTER:
	(
		echo "INFO      | $(date) | Removing problem SNP #1... "
		line="$(head -n1 ./zeroSumRows.txt)"
	#
			if [[ $((line % 2)) -eq 0 ]]; then
				##echo "$var is even"; 
				MY_LINE_MINUS_ONE="$(calc $line-1)";
				sed -i ''"$MY_LINE_MINUS_ONE"','"$line"'d' ./bayenv2_input.txt;
			else 
				##echo "$var is odd"; 
				MY_LINE_PLUS_ONE="$(calc $line+1)";
				sed -i ''"$line"','"$MY_LINE_PLUS_ONE"'d' ./bayenv2_input.txt; 
			fi
	#
	)

	sed -i '1d' ./zeroSumRows.txt

	(
		count=1
		while read line; do
	#
			MY_DIFF="$(calc $count*2)"
			MY_NEW_LINE="$(calc $line-$MY_DIFF)"
			if [[ $((line % 2)) -eq 0 ]]; then
				##echo "$var is even"; 
				MY_NEW_LINE_MINUS_ONE="$(calc $MY_NEW_LINE-1)";
				sed -i ''"$MY_NEW_LINE_MINUS_ONE"','"$MY_NEW_LINE"'d' ./bayenv2_input.txt;
			else 
				##echo "$var is odd"; 
				MY_NEW_LINE_PLUS_ONE="$(calc $MY_NEW_LINE+1)";
				sed -i ''"$MY_NEW_LINE"','"$MY_NEW_LINE_PLUS_ONE"'d' ./bayenv2_input.txt; 
			fi
	#
		MY_COUNT_PLUS_ONE="$(calc $count+1)"
		echo "INFO      | $(date) | $((count++))+1 = Removing problem SNP #$MY_COUNT_PLUS_ONE... "
		done < ./zeroSumRows.txt
	
	)
	
	fi

}

removeFixedSNPs



echo ""
echo "INFO      | $(date) | Done prepping Bayenv2 input file from SNP genotypes using minor012-bayenv2.sh."
echo "INFO      | $(date) | Bye.
"
#
#
#
######################################### END ############################################

exit 0

